---
title: "1. Overlaying treatment polygons with Treemap"
author: "Kayla Johnston and Carmen Tubbesing"
date: "`r Sys.Date()`"
format: 
  html:
    embed-resources: TRUE
    toc: TRUE
---

## Define the name and ID number of the project
```{r}
proj_name <- "Lake_County_Wildfire_Resilience_Phase3"
```

```{r}
project_ID <- "8GG24602"
```

# This run is for project `r project_ID`, AKA `r proj_name`

# Files needed:
-  TreeMap datasets, clipped to CA (.tif for each year)
-  A directory with treatment shapefiles within it (can be in nested/zipped folders)
-  The FVS variants and locations shapefile

```{r, include = F}
# load libraries
library(terra) # for handling spatial data
library(tidyverse) # for data manipulation
library(readxl) # for reading excel workbooks
library(sf)
library(writexl)
library(ggplot2)
library(gganimate)
library(flextable)
library(gridExtra)
```

# Setup

*These are the things you have to edit between runs*

## Define which year of TreeMap you want to use
```{r}
tm <- 2022 # Options = 2016, 2020, 2022
```

## Define directory with treatment shapefiles in it
```{r}
trt_dir <- "~/CCI/QMs/Forest Health QM/Test runs/new 2025 projects/8GG24602/Shapefiles/"
```

## Define directory with CA perimeter shapefile in it
```{r}
ca_dir <- "~/Reference data/CA boundary/ca-state-boundary"
```


## Define input and output dir
```{r}
input_dir <- "~/../../Data_heavy_projects/Forest_QM_automation/data/TreeMap"
output_dir <- "~/../../Data_heavy_projects/Forest_QM_automation/temp"
```

## Define FVS variant location shapefile
```{r}
fvs_varloc_shp_path <- file.path(input_dir, "../../FVS_files/FVSVariantMap20210525/FVS_Variants_and_Locations.shp")
fvs_varloc <- st_read(fvs_varloc_shp_path, )
```

## Clear output directory (`temp`)
```{r}
unlink(paste0(output_dir, "/*"), recursive = TRUE)
```


## Read in TreeMap dataset(s)

### TreeMap rasters
```{r}
tm16file <- file.path(input_dir, "TreeMap2016/tm2016_ca/tm2016_ca.tif") 
tm20file <- file.path(input_dir, "TreeMap2020/tm2020_ca/TM2020_CA.tif")
tm22file <- file.path(input_dir, "TreeMap2022/tm2022_ca.tif")
```

```{r}
if(tm == 2016){
  tm16 <- rast(tm16file)
  names(tm16) <- "TM_ID"
  tmrast <- tm16 
} else if(tm == 2020){
  tm20 <- rast(tm20file)
  tmrast <- tm20
} else if(tm == 2022){
  tm22 <- rast(tm22file)
  tmrast <- tm22
} else{
  print("ERROR: Not a valid TreeMap year")
}
```

## If necessary, unzip treatment shapefiles
```{r}
# List all zipped files in the Shapefiles folder
zip_files <- list.files(trt_dir, pattern = "\\.zip$", full.names = TRUE)

# Loop through each zipped file and extract its contents
for (zip_file in zip_files) {
  unzip(zip_file, exdir = trt_dir)
}

print("All files have been extracted.")
```

# List shapefiles in dir,  ignoring those with "buffer" or "boundary" in the name
```{r}
shapefiles <- list.files(
  path = trt_dir,
  pattern = "\\.shp$",
  full.names = TRUE,
  recursive = TRUE
)

shapefiles <- shapefiles[!grepl("buffer", shapefiles)]
shapefiles <- shapefiles[!grepl("Boundary", shapefiles)]
shapefiles <- shapefiles[!grepl("boundary", shapefiles)]
basename(shapefiles)
```

# If shapefile is multi-part, break it up by Grant ID #
```{r}
shp_list <- list()
for(i in 1:length(shapefiles)){
  shp <- st_read(shapefiles[i], quiet= T)
  if(length(shp$Grant_ID) > 1){
    for(j in 1:length(shp$Grant_ID)){
      shp_grant <- shp %>% 
        filter(Grant_ID == shp$Grant_ID[j])
      shp_list[[j]] <- shp_grant
    }
  }
}
```

## Otherwise, create shp_list
```{r}
shp_list <- list()
for(i in 1:length(shapefiles)){
  shp <- st_read(shapefiles[i], quiet= T)
  shp_list[[i]] <- shp
}
```

```{r}
print(paste("There are", length(shapefiles), "shapefiles and", length(shp_list), "polygon features, each saved in `shp_list`"))
```

# Prep `fvs_varloc`
```{r}
fvs_varloc <- st_transform(fvs_varloc, crs= 4326)
fvs_varloc <- vect(fvs_varloc)
fvs_varloc <- makeValid(fvs_varloc)
```

# Define functions

## Function for AOI prep & intersection with variant shapefile
```{r}
aoi_prep <- function(aoi, fvs_varloc, tm_rast) {
  #' @param aoi the AOI polygon
  #' @param fvs_varloc the FVS variants and locations shapefile
  #' @param tm_rast the TreeMap raster
  #' @return A new AOI with a single polygon for each original polygon-FVSVarLoc combination,
  #' projected to match the projection of the TreeMap raster and includes lat/long of each polygon 
  #' centroid, a STAND_ID, and acres per polygon
  aoi <- st_zm(aoi)
  aoi <- st_transform(aoi, crs = 4326)
  aoi <- vect(aoi)
  aoi <- makeValid(aoi)

  single_part_polygons <- disagg(aoi) #aoi multipart polygon to single part
  aoi_varlocs <- crop(fvs_varloc, single_part_polygons) # crop FVS varloc to the AOI single part polygons
  aoi_varlocs$STAND_ID <- 1:nrow(aoi_varlocs) #assign a STAND_ID to each polygon record
  aoi_centroids <- centroids(aoi_varlocs, TRUE) #create centroids spatvector
  coords_df <- crds(aoi_centroids, df = TRUE) #convert centroids spatvector to df
  colnames(coords_df) <- c("Longitude", "Latitude") #rename columns of centroids df
  aoi_varlocs <- cbind(aoi_varlocs, coords_df) #column bind the centroids df to the aoi spatvector
  # In order to convert aoi_varlocs to the crs of TreeMap, I have to convert it into an sf object and back
  aoi_varlocs <- st_as_sf(aoi_varlocs) #convert to sf object
  aoi_proj <- st_transform(aoi_varlocs, crs(tm_rast))
  # Calculate area of each item in aoi_proj
  aoi_proj$area <- st_area(aoi_proj)
  aoi_proj <- vect(aoi_proj)
  return(aoi_proj)
}
```

# Create impact area areas file

## Merge the shapefiles into one big polygon, then buffer, then dissolve
```{r}
shp_list <- lapply(shp_list, st_zm)
shp_list_valid <- lapply(shp_list, st_make_valid)
merged_sf <- bind_rows(shp_list)
impact_area <- st_buffer(merged_sf, dist = 1500)
impact_area <- st_union(impact_area)
```

## Map it 
```{r}
map_buffer <- ggplot() +
  geom_sf(data = merged_sf, fill = "lightblue", color = "black", alpha = 0.6) +
  geom_sf(data = impact_area, color = "red", fill = "lightpink", size = 1, alpha = .2) 
```

```{r}
ia <- aoi_prep(aoi = impact_area, 
           fvs_varloc = fvs_varloc,
           tm_rast = tmrast)
# Clip, mask, and convert to polygons
tm_poly <- crop(tmrast, ia) %>% 
  mask(ia) %>% 
  as.polygons %>% 
  makeValid()

# Intersect
intersected <- terra::intersect(tm_poly,ia)

# convert intersected to sf 
intersected_sf <- sf::st_as_sf(intersected)
```

```{r}
map_raster <- ggplot(data = intersected_sf) +
  geom_sf(aes(fill = as.factor(TM_ID)), color = NA) +
  labs(fill = "TreeMapper ID (TM_ID)")+
  theme(legend.position = "none")
```

```{r}
grid.arrange(map_buffer, map_raster, ncol = 2)
```

*Note*: These maps use different projections

## Save prepped rasters for impact area
```{r}
# Remove columns
intersected_sf <- intersected_sf %>% 
  select(TM_ID, FVSVariant, FVSLocCode, STAND_ID, Latitude, Longitude)
# Calculate areas
intersected <- intersected_sf %>% 
  mutate(area_m = as.numeric(st_area(intersected_sf))) %>% 
  mutate(area_ac = area_m/4046.8726098743) %>% 
  st_drop_geometry()

# Write results to table and to shapefile
file_name <- paste(output_dir, "/", project_ID, "_Impact_areas.xlsx", sep = "")
write_xlsx(intersected, file_name)

st_write(intersected_sf, output_dir, paste("intersected", project_ID, "Impact_Area", sep = "_"), driver = "ESRI Shapefile", delete_layer = T, quiet = T)
```

# Crop treemap to size of the impact area to reduce computing time for the rest of the script
```{r}
tmrast <- crop(tmrast, ia)
```

# Loop the areas file prep across all shapefiles in a path

For each shapefile in `trt_dir`, calculate the area of each value of TM_ID that intersects with that polygon and save as an excel file
```{r}
map_list <- list()
treemap_areas_list <- list()
shp_areas_list <- list()
TCN_list <- list()
for (i in 1:length(shp_list)) {
  print(i)
  shp <- shp_list[[i]]
  if(length(shp$Grant_ID) > 1){
    base_name <- paste("SB63", shp$Grant_ID, sep = "_")
  } else{
    base_name <- tools::file_path_sans_ext(basename(shapefiles[i]))
  }
  
  aoi_prepped <- aoi_prep(aoi = shp, 
           fvs_varloc = fvs_varloc,
           tm_rast = tmrast)
  print(paste("Created aoi_prepped for", base_name))
  # Clip, mask, and convert to polygons
  tm_poly <- crop(tmrast, aoi_prepped) %>% 
    mask(aoi_prepped) %>% 
    as.polygons %>% 
    makeValid()
  # Intersect
  intersected <- terra::intersect(tm_poly, aoi_prepped)
  print(paste("Created TreeMap Polygons for", base_name))

  # convert intersected to sf 
  intersected_sf <- sf::st_as_sf(intersected)

  # Plot using ggplot2
  map_name <- paste("map", base_name, sep = "_")
  map <- ggplot(data = intersected_sf) +
    geom_sf(aes(fill = as.factor(TM_ID)), color = NA) +
    labs(fill = "TreeMapper ID (TM_ID)")+
    theme(legend.position = "none")+
    geom_sf(data = shp, fill = NA)
  map_list[[map_name]] <- map
  
  # Remove columns
  intersected_sf <- intersected_sf %>% 
    select(TM_ID, FVSVariant, FVSLocCode, STAND_ID, Latitude, Longitude)
  # Calculate areas
  intersected <- intersected_sf %>% 
    mutate(area_m = as.numeric(st_area(intersected_sf))) %>% 
    mutate(area_ac = area_m/4046.8726098743) %>% 
    st_drop_geometry()
  intersected %>% head()
  # Write results to table and to shapefile
  file_name <- paste(output_dir, "/", base_name, "_areas_TM.xlsx", sep = "")
  write_xlsx(intersected, file_name)
  
  treemap_areas_list[[base_name]] <- sum(intersected$area_ac)
  shp_areas_list[[base_name]] <- st_area(shp)
  if("Tcn" %in% names(shp)){
    names(shp)[names(shp) == "Tcn"] <- toupper("Tcn")
  }
  TCN_list[[base_name]] <- shp$TCN
  st_write(intersected_sf, output_dir, paste("intersected", base_name, sep = "_"), driver = "ESRI Shapefile", delete_layer = T, quiet = T)
}
```

# Find TreeMap acres for each polygon as a percentage of total shapefile area

Treemap acres = the acreage of the polygon that excludes non-forested pixels
```{r}
treemap_areas_df<- tibble(
  Name = names(treemap_areas_list),
  Value = unlist(treemap_areas_list)
) 

treemap_areas_df <- treemap_areas_df %>% 
  mutate(Value = round(Value)) %>% 
  rename("TreeMap Acres" = Value) %>% 
  rename(Shapefile = Name)

shp_areas_df <- tibble(
  Name = names(shp_areas_list),
  Value = unlist(shp_areas_list)
) 

tcn_df <- tibble(
  Shapefile = names(TCN_list),
  TCN = unlist(TCN_list)
)

shp_areas_df <- shp_areas_df %>% 
  mutate(Value = Value/4046.86) %>% 
  mutate(Value = round(Value)) %>% 
  rename("Shapefile Acres" = Value) %>% 
  rename(Shapefile = Name)

shp_areas_df <- full_join(tcn_df, shp_areas_df)

areas_table <- full_join(shp_areas_df, treemap_areas_df) %>% 
  mutate(Percentage = round(`TreeMap Acres`/`Shapefile Acres`*100, 1))
# Print a pretty table
flextable(areas_table)
```

# Maps & Overlaps

## Plot all treatments together and highlight overlaps
```{r}
combined <- lapply(seq_along(shp_list), function(i) {
  map <- shp_list[[i]]
  map$source_id <- paste0("Layer_", i)  # Add a source ID if needed
  map
}) |> bind_rows()

# Ensure valid geometries
combined <- st_make_valid(combined %>% st_zm)

# Make TCN column all caps if necessary
if("Tcn" %in% names(combined)){
  names(combined)[names(combined) == "Tcn"] <- toupper("Tcn")
}

# Find overlapping areas
overlaps <- st_intersection(combined) %>%
  filter(n.overlaps > 1) %>%  # Keep only actual overlaps
  mutate(Name = "Overlap")

plot_data <- bind_rows(combined, overlaps)
```

```{r, out.width="100%", fig.height=16}
ggplot() +
  geom_sf(data = combined, aes(fill = as.factor(TCN), col = as.factor(TCN)), alpha = 0.5) +
  geom_sf(data = overlaps, fill = "black", color = "black", alpha = 0.6) +
  theme_minimal() +
  labs(title = "All TCNs -- Overlaps are Black",
       fill = "TCN", 
       col = "TCN")
```


## Plot each treatment separately
```{r}
for (i in seq_along(map_list)) {
  print(names(map_list)[i])
  print(map_list[[i]])
}
```

## List overlapping pairs
```{r}
# Create a pairwise intersection matrix
overlap_list <- st_intersects(combined, sparse = F)
rownames(overlap_list) <- combined$TCN
colnames(overlap_list) <- combined$TCN
diag(overlap_list) <- FALSE

# Find positions of FALSE values
true_positions <- which(overlap_list == TRUE, arr.ind = TRUE)

# Add row and column names
result <- data.frame(
  Row = rownames(overlap_list)[true_positions[, 1]],
  Column = colnames(overlap_list)[true_positions[, 2]]
)

# Create a consistent ordering for each pair
result$pair_id <- apply(result, 1, function(x) paste(sort(x), collapse = "/"))
# Keep only unique pairs
unique_df <- result[!duplicated(result$pair_id), c("Row", "Column")]
for(i in 1:nrow(unique_df)){
  print(paste(unique_df[i, 1], "overlaps with", unique_df[i, 2]))
}
```


```{r}
# Find overlapping areas
overlaps <- st_intersection(combined) %>%
  filter(n.overlaps > 1) %>%  # Keep only actual overlaps
  mutate(Name = "Overlap")

# plot_data <- bind_rows(combined, overlaps)
# 
# combined_overlap <- combined %>% 
#   filter(TCN %in% unique_df$Row | TCN %in% unique_df$Column)
# 

```

## Plot each treatment group (e.g. 1.1 and 1.2) together, with overlaps
```{r}
combined$treatment_group <- sub("\\..*", "", combined$TCN)
overlaps$treatment_group <- sub("\\..*", "", overlaps$TCN)
```

```{r}
treatment_groups <- unique(combined$treatment_group)
map_list2 <- list()
for(i in treatment_groups){
  combined_i <- combined %>% 
    filter(treatment_group==i)
  overlaps_i <- overlaps %>% 
    filter(treatment_group == i) 
  map <- ggplot() +
    geom_sf(data = combined_i, aes(fill = as.factor(TCN), col = as.factor(TCN)), alpha = 0.5) +
    geom_sf(data = overlaps_i, fill = "black", color = "black", alpha = 0.6) +
    theme_minimal() +
    labs(title = paste0("Treatment group ", i ,", Black is overlap"),
         fill = "TCN", 
         col = "TCN")
  map_name <- paste("Treatment_group", i, sep = "_")
  map_list2[[map_name]] <- map
}
for (i in seq_along(map_list2)) {
  print(names(map_list2)[i])
  print(map_list2[[i]])
}
```

## Plot the project in California to check FVS variant selection
```{r}
ca <- st_read(file.path(ca_dir, "CA_State_TIGER2016_5070.shp"))
```

```{r}
fvs_varloc <- st_as_sf(fvs_varloc) %>% 
  filter(FVSVariant %in% c("WS", "NC", "CA", "SO")) %>% 
  group_by(FVSVariant) |>
  summarise(geometry = st_union(geometry), .groups = "drop")
```

```{r}
centroids <- st_centroid(shp %>% st_zm())
circle_buffer <- st_buffer(centroids, dist = 8000)

ggplot() +
      geom_sf(data = fvs_varloc,  aes(fill = FVSVariant), alpha = 0.2)+
    geom_sf(data = ca, fill = NA)+
  geom_sf(data = circle_buffer, col = "red", fill = "red")

```

```{r}
print(paste("FVS Variant selection for", basename(file_name), "is", unique(intersected$FVSVariant)))
```


---
title: "1. Overlaying treatment polygons with Treemap"
author: "Kayla Johnston and Carmen Tubbesing"
date: "`r Sys.Date()`"
format: 
  html:
    embed-resources: TRUE
    toc: TRUE
---

## Define the name and ID number of the project

```{r}
proj_name <- "Upper Pit River Forest Health Project, Phase 2"
```

```{r}
project_ID <- "8GG20600"
```

## Define impact area buffer distance, in meters
```{r}
buffer_dist <- 1500
```

# Define which treatments are reforestation or biomass utilization. These do not require FVS inputs.
```{r}
noFVS <- c(0)
```

## Define which year of TreeMap you want to use
```{r}
tm <- 2022 # Options = 2016, 2020, 2022
```

## Define directory with treatment shapefiles in it
```{r}
trt_dir <- "~/CCI/QMs/Forest Health QM/Test runs/reforestation/8GG20600/8GG20600_CloseoutShapefiles"
```


# This run is for project `r project_ID`, AKA `r proj_name`

# Files needed:

-   TreeMap datasets, clipped to CA (.tif for each year)
-   A directory with treatment shapefiles within it (can be in nested/zipped folders)
-   The FVS variants and locations shapefile

```{r, include = F}
# List of required packages
required_packages <- c(
  "terra",       
  "tidyverse",   
  "readxl",      
  "sf",
  "writexl",
  "ggplot2",
  "flextable",
  "gridExtra"
)

# Install missing packages
missing_packages <- required_packages[!(required_packages %in% installed.packages()[,"Package"])]

if (length(missing_packages)>0) {
  install.packages(missing_packages)
}

# Load all packages
lapply(required_packages, require, character.only = TRUE)
```

# Setup

*These are the things you have to edit between runs*

### Define directory with CA perimeter shapefile in it

```{r}
ca_dir <- "~/Reference data/CA boundary/ca-state-boundary"
```

### Define input and output dir

```{r}
input_dir <- "~/../../Data_heavy_projects/Forest_QM_automation/data/TreeMap"
output_dir <- "~/../../Data_heavy_projects/Forest_QM_automation/temp"
output_dir_randig <- "~/../../Data_heavy_projects/Forest_QM_automation/randig_shapefiles"
```

### Define FVS variant location shapefile

```{r}
fvs_varloc_shp_path <- file.path(input_dir, "../../FVS_files/FVSVariantMap20210525/FVS_Variants_and_Locations.shp")
fvs_varloc <- st_read(fvs_varloc_shp_path, quiet = T)
```

### Clear output directory (`temp`)
```{r}
unlink(paste0(output_dir, "/*"), recursive = TRUE)
```

### Read in TreeMap dataset(s)
```{r}
tm16file <- file.path(input_dir, "TreeMap2016/tm2016_ca/tm2016_ca.tif") 
tm20file <- file.path(input_dir, "TreeMap2020/tm2020_ca/TM2020_CA.tif")
tm22file <- file.path(input_dir, "TreeMap2022/tm2022_ca.tif")
```

```{r}
if(tm == 2016){
  tm16 <- rast(tm16file)
  names(tm16) <- "TM_ID"
  tmrast <- tm16 
} else if(tm == 2020){
  tm20 <- rast(tm20file)
  tmrast <- tm20
} else if(tm == 2022){
  tm22 <- rast(tm22file)
  tmrast <- tm22
} else{
  print("ERROR: Not a valid TreeMap year")
}
```

## If necessary, unzip treatment shapefiles

```{r}
# List all zipped files in the Shapefiles folder
zip_files <- list.files(trt_dir, pattern = "\\.zip$", full.names = TRUE)

# Loop through each zipped file and extract its contents
for (zip_file in zip_files) {
  unzip(zip_file, exdir = trt_dir)
}

print("All files have been extracted.")
```

# List shapefiles in `trt_dir`, ignoring those with "buffer" or "boundary" in the name

```{r}
shapefiles <- list.files(
  path = trt_dir,
  pattern = "\\.shp$",
  full.names = TRUE,
  recursive = TRUE
)

shapefiles <- shapefiles[!grepl("buffer", shapefiles)]
shapefiles <- shapefiles[!grepl("Boundary", shapefiles)]
shapefiles <- shapefiles[!grepl("boundary", shapefiles)]
basename(shapefiles)
```

## Create shp_list
```{r}
shp_list <- list()
for(i in 1:length(shapefiles)){
  shp <- st_read(shapefiles[i], quiet= T)
  shp_list[[i]] <- shp
}
```

```{r}
print(paste("There are", length(shapefiles), "shapefiles and", length(shp_list), "polygon features, each saved in `shp_list`"))
```

# Prepare shapefiles & TreeMap raster for spatial overlay


### Make sure that each shapefile has TCN variable and rename if necessary
```{r}
# Define possible names for the TCN column
tcn_variants <- c("Tcn", "TreatmentC", "tcn", "treatmentc")

# Function to rename the TCN column in a single sf object
rename_tcn_column <- function(sf_obj) {
  current_names <- names(sf_obj)
  match_name <- current_names[current_names %in% tcn_variants]
  if (length(match_name) == 1) {
    names(sf_obj)[names(sf_obj) == match_name] <- "TCN"
  }
  return(sf_obj)
}

# Apply the function to each element in the list
shp_list <- lapply(shp_list, rename_tcn_column)
```

```{r}
# Define possible names for the TCN column
Tobj_variants <- c("Tobj", "TreatmentO", "TObj")

# Function to rename the TCN column in a single sf object
rename_Tobj_column <- function(sf_obj) {
  current_names <- names(sf_obj)
  match_name <- current_names[current_names %in% Tobj_variants]
  if (length(match_name) == 1) {
    names(sf_obj)[names(sf_obj) == match_name] <- "Tobj"
  }
  return(sf_obj)
}

# Apply the function to each element in the list
shp_list <- lapply(shp_list, rename_Tobj_column)
```

# Overlap treatments and FVS variants

### Prep `fvs_varloc`
```{r}
fvs_varloc <- vect(fvs_varloc)
fvs_varloc <- makeValid(fvs_varloc)
fvs_varloc <- project(fvs_varloc, crs(tmrast))
fvs_sf <- st_as_sf(fvs_varloc)
```


### Reproject each shp to match `fvs_sf`
```{r}
for(i in 1:length(shp_list)){
  shp_list[[i]] <- st_transform(shp_list[[i]], st_crs(fvs_sf))
}
```

### Add FVS variant column to each shapefile
```{r}
# Function to intersect and assign dominant FVSVariant
assign_fvsvariant <- function(shp) {
  # Intersect with fvs_sf
  intersection <- st_intersection(shp, fvs_sf)
  
  # Calculate area of each intersected piece
  intersection$area <- st_area(intersection)
  
  # Summarize area by FVSVariant for each original polygon
  dominant_variant <- intersection %>%
    arrange(desc(area)) %>% 
    slice_max(area, n = 1) %>%
    select(FVSVariant) %>% 
    st_drop_geometry() %>% 
    unlist()
  
  # Join back to original shp
  shp$FVSVariant <- dominant_variant
  return(shp)
}
```

```{r}
shp_list <- lapply(shp_list, assign_fvsvariant)
```


# Loop the areas calculations across all shapefiles in a path

For each shapefile in `trt_dir`, calculate the area of each value of TM_ID that intersects with that polygon and save as an excel file

```{r}
map_list <- list()
treemap_areas_list <- list()
shp_areas_list <- list()
TCN_list <- list()
for (i in 1:length(shp_list)) {
  print(i)
  shp_sf <- shp_list[[i]]
  shp <- vect(shp_sf)
  base_name <- tools::file_path_sans_ext(basename(shapefiles[i]))

  # if(shp_sf$TCN %in% noFVS){
  #   print(paste("Skipping TCN =", shp_sf$TCN))
  #   next
  # }
  # Start with impact area
  shp_buff <- buffer(shp, width = buffer_dist)

  # Clip, mask, and convert to polygons
  shp_buff <- project(shp_buff, crs(tmrast))
  tm_poly_buff <- crop(tmrast, shp_buff, mask = T) %>% 
    as.polygons %>% 
    makeValid()
  # Intersect
  intersected_buff <- terra::intersect(tm_poly_buff, shp_buff)
  print(paste("Created TreeMap Polygons for impact area of", base_name))

  # convert intersected to sf 
  intersected_sf_buff <- sf::st_as_sf(intersected_buff)
  
  # Remove columns
  intersected_sf_buff  <- intersected_sf_buff  %>% 
    select(TM_ID, FVSVariant)
  # Calculate areas
  intersected_buff  <- intersected_sf_buff  %>% 
    mutate(area_m = as.numeric(st_area(intersected_sf_buff ))) %>% 
    mutate(area_ac = area_m/4046.8726098743) %>% 
    st_drop_geometry()
  
  # Write results to table and to shapefile
  file_name <- paste(output_dir, "/", base_name, "_areas_IA.xlsx", sep = "")
  write_xlsx(intersected_buff, file_name)

  # Now do for treatment no buffer
  tm_poly <- crop(tmrast, shp, mask = T) %>% 
    as.polygons %>% 
    makeValid()
  # Intersect
  intersected <- terra::intersect(tm_poly, shp)
  print(paste("Created TreeMap Polygons for trt area of", base_name))

  # convert intersected to sf 
  intersected_sf<- sf::st_as_sf(intersected)
  
  # Remove columns
  intersected_sf <- intersected_sf %>% 
    select(TM_ID, FVSVariant)
  # Calculate areas
  intersected <- intersected_sf %>% 
    mutate(area_m = as.numeric(st_area(intersected_sf))) %>% 
    mutate(area_ac = area_m/4046.8726098743) %>% 
    st_drop_geometry()
  # Write results to table and to shapefile
  file_name <- paste(output_dir, "/", base_name, "_areas.xlsx", sep = "")
  write_xlsx(intersected, file_name)
  
    # Plot using ggplot2
  map_name <- paste("map", base_name, sep = "_")
  map <- ggplot(data = intersected_sf) +
    geom_sf(aes(fill = as.factor(TM_ID)), color = NA) +
    #geom_sf(data = intersected_sf_buff)+
    labs(fill = "TreeMapper ID (TM_ID)")+
    theme(legend.position = "none")+
    geom_sf(data = shp_sf, fill = NA)
  map_list[[map_name]] <- map
  
  treemap_areas_list[[base_name]] <- sum(intersected$area_ac)
  shp_areas_list[[base_name]] <- st_area(shp_sf)

  TCN_list[[base_name]] <- shp_sf$TCN
  st_write(intersected_sf, output_dir, paste("intersected", base_name, sep = "_"), driver = "ESRI Shapefile", delete_layer = T, quiet = T)
}
```

# Find TreeMap acres for each polygon as a percentage of total shapefile area

Treemap acres = the acreage of the polygon that excludes non-forested pixels

```{r}
treemap_areas_df<- tibble(
  Name = names(treemap_areas_list),
  Value = unlist(treemap_areas_list)
) 

treemap_areas_df <- treemap_areas_df %>% 
  mutate(Value = round(Value)) %>% 
  rename("TreeMap Acres" = Value) %>% 
  rename(Shapefile = Name)

shp_areas_df <- tibble(
  Name = names(shp_areas_list),
  Value = unlist(shp_areas_list)
) 

tcn_df <- tibble(
  Shapefile = names(TCN_list),
  TCN = unlist(TCN_list)
)

shp_areas_df <- shp_areas_df %>% 
  mutate(Value = Value/4046.86) %>% 
  mutate(Value = round(Value)) %>% 
  rename("Shapefile Acres" = Value) %>% 
  rename(Shapefile = Name)

shp_areas_df <- full_join(tcn_df, shp_areas_df)

areas_table <- full_join(shp_areas_df, treemap_areas_df) %>% 
  mutate(Percentage = round(`TreeMap Acres`/`Shapefile Acres`*100, 1))
# Print a pretty table
flextable(areas_table)
```

# Maps & Overlaps

### Combine all shapefiles for plotting
```{r}
combined <- lapply(seq_along(shp_list), function(i) {
  map <- shp_list[[i]]
  map$source_id <- paste0("Layer_", i)  # Add a source ID if needed
  map$TCN <- as.character(map$TCN)
  map
}) |> bind_rows()

# Ensure valid geometries
combined <- st_make_valid(combined %>% st_zm)
```

### Plot all treatments together and highlight overlaps
```{r}
# Find overlapping areas
overlaps <- st_intersection(combined) %>%
  filter(n.overlaps > 1) %>%  # Keep only actual overlaps
  mutate(Name = "Overlap")

plot_data <- bind_rows(combined, overlaps)
```

```{r, out.width="100%", fig.height=16}
ggplot() +
  geom_sf(data = combined, aes(fill = as.factor(TCN), col = as.factor(TCN)), alpha = 0.5) + 
  geom_sf(data = overlaps, fill = "black", color = "black", alpha = 0.5) +
  theme_minimal() +
  labs(title = "All TCNs -- Overlaps are darkened",
       fill = "TCN", 
       col = "TCN")
```

### Plot each treatment separately

```{r}
for (i in seq_along(map_list)) {
  print(names(map_list)[i])
  print(map_list[[i]])
}
```

### List overlapping pairs

```{r}
# Create a pairwise intersection matrix
overlap_list <- st_intersects(combined, sparse = F)
rownames(overlap_list) <- combined$TCN
colnames(overlap_list) <- combined$TCN
diag(overlap_list) <- FALSE

# Find positions of FALSE values
true_positions <- which(overlap_list == TRUE, arr.ind = TRUE)

# Add row and column names
result <- data.frame(
  Row = rownames(overlap_list)[true_positions[, 1]],
  Column = colnames(overlap_list)[true_positions[, 2]]
)

# Create a consistent ordering for each pair
result$pair_id <- apply(result, 1, function(x) paste(sort(x), collapse = "/"))
# Keep only unique pairs
unique_df <- result[!duplicated(result$pair_id), c("Row", "Column")]
for(i in 1:nrow(unique_df)){
  print(paste(unique_df[i, 1], "overlaps with", unique_df[i, 2]))
}
```

```{r}
# Find overlapping areas
overlaps <- st_intersection(combined) %>%
  filter(n.overlaps > 1) %>%  # Keep only actual overlaps
  mutate(Name = "Overlap")
```

### Plot each treatment group (e.g. 1.1 and 1.2) together, with overlaps

```{r}
combined$treatment_group <- sub("\\..*", "", combined$TCN)
overlaps$treatment_group <- sub("\\..*", "", overlaps$TCN)
```

```{r}
treatment_groups <- unique(combined$treatment_group)
map_list2 <- list()
for(i in treatment_groups){
  combined_i <- combined %>% 
    filter(treatment_group==i)
  overlaps_i <- overlaps %>% 
    filter(treatment_group == i) 
  map <- ggplot() +
    geom_sf(data = combined_i, aes(fill = as.factor(TCN), col = as.factor(TCN)), alpha = 0.5) +
    geom_sf(data = overlaps_i, fill = "black", color = "black", alpha = 0.6) +
    theme_minimal() +
    labs(title = paste0("Treatment group ", i ,", Dark is overlap"),
         fill = "TCN", 
         col = "TCN")
  map_name <- paste("Treatment_group", i, sep = "_")
  map_list2[[map_name]] <- map
}
for (i in seq_along(map_list2)) {
  print(names(map_list2)[i])
  print(map_list2[[i]])
}
```

## Plot the project in California to check FVS variant selection

```{r}
ca <- st_read(file.path(ca_dir, "CA_State_TIGER2016_5070.shp"))
```

```{r}
fvs_varloc <- st_as_sf(fvs_varloc) %>% 
  filter(FVSVariant %in% c("WS", "NC", "CA", "SO")) %>% 
  group_by(FVSVariant) |>
  summarise(geometry = st_union(geometry), .groups = "drop")
```

```{r}
centroids <- st_centroid(shp %>% st_zm())
circle_buffer <- st_buffer(centroids, dist = 8000)

ggplot() +
      geom_sf(data = fvs_varloc,  aes(fill = FVSVariant), alpha = 0.2)+
    geom_sf(data = ca, fill = NA)+
  geom_sf(data = circle_buffer, col = "red", fill = "red")

```

```{r}
print(paste("FVS Variant selection for", basename(file_name), "is", unique(intersected$FVSVariant)))
```

---
title: "1. Overlaying treatment polygons with Treemap"
author: "Carmen Tubbesing"
date: "`r Sys.Date()`"
format: 
  html:
    embed-resources: TRUE
    toc: TRUE
---
# User Inputs - Change these each project

*These are the things you have to edit between projects*

### Define the name and ID number of the project

```{r}
proj_name <- "Western Klamath Fire Resilience and Forest Health Project"
```

```{r}
project_ID <- "8GG22624"
```

### Define impact area buffer distance, in meters
```{r}
buffer_dist <- 1500
```

### Define which treatments are site prep, biomass utilization, or other treatment types that do not require FVS inputs.

List the TCNs of treatments not needing FVS input files
```{r}
noFVS <- c()
```

Note: Do not include reforestation treatments in `noFVS`. Even though FVS is not run on them, the FVS input files are used to determine species of regenerating conifers.

### Define which year of TreeMap you want to use
```{r}
tm <- 2022 # Options = 2016, 2020, 2022
```

## Define directory with treatment shapefiles in it
```{r}
trt_dir <- "~/CCI/QMs/Forest Health QM/Test runs/8GG22624/shapefiles"
```


# This run is for project `r project_ID`, AKA `r proj_name`

# Files needed:

-   TreeMap datasets, clipped to CA (.tif for each year)
-   A directory with treatment shapefiles within it (can be in nested/zipped folders)
-   The FVS variants and locations shapefile

```{r, include = F}
# List of required packages
required_packages <- c(
  "terra",       
  "tidyverse",   
  "readxl",      
  "sf",
  "writexl",
  "ggplot2",
  "flextable",
  "gridExtra",
  "RColorBrewer"
)

# Install missing packages
missing_packages <- required_packages[!(required_packages %in% installed.packages()[,"Package"])]

if (length(missing_packages)>0) {
  install.packages(missing_packages)
}

# Load all packages
lapply(required_packages, require, character.only = TRUE)
```

# Setup

*These are the things you have to edit if it's your first time using this script*

### Define directory with CA perimeter shapefile in it

```{r}
ca_dir <- "~/Reference data/CA boundary/ca-state-boundary"
```

### Define input and output dir

```{r}
input_dir <- "~/../../Data_heavy_projects/Forest_QM_automation/data/TreeMap"
output_dir <- "~/../../Data_heavy_projects/Forest_QM_automation/temp"
output_dir_randig <- "~/../../Data_heavy_projects/Forest_QM_automation/randig_shapefiles"
```

### Define FVS variant location shapefile

```{r}
fvs_varloc_shp_path <- file.path(input_dir, "../../FVS_files/FVSVariantMap20210525/FVS_Variants_and_Locations.shp")
fvs_varloc <- st_read(fvs_varloc_shp_path, quiet = T)
```

### Clear output directory (`temp`)
```{r}
unlink(paste0(output_dir, "/*"), recursive = TRUE)
```

### Read in TreeMap dataset(s)
```{r}
tm16file <- file.path(input_dir, "TreeMap2016/tm2016_ca/tm2016_ca.tif") 
tm20file <- file.path(input_dir, "TreeMap2020/tm2020_ca/TM2020_CA.tif")
tm22file <- file.path(input_dir, "TreeMap2022/tm2022_ca.tif")
```

```{r}
if(tm == 2016){
  tm16 <- rast(tm16file)
  names(tm16) <- "TM_ID"
  tmrast <- tm16 
} else if(tm == 2020){
  tm20 <- rast(tm20file)
  tmrast <- tm20
} else if(tm == 2022){
  tm22 <- rast(tm22file)
  tmrast <- tm22
} else{
  print("ERROR: Not a valid TreeMap year")
}
```

## If necessary, unzip treatment shapefiles

```{r}
# List all zipped files in the Shapefiles folder
zip_files <- list.files(trt_dir, pattern = "\\.zip$", full.names = TRUE)

# Loop through each zipped file and extract its contents
for (zip_file in zip_files) {
  unzip(zip_file, exdir = trt_dir)
}

print("All zipped files have been extracted.")
```

## List shapefiles in `trt_dir`, ignoring those with "buffer" or "boundary" in the name

```{r}
shapefiles <- list.files(
  path = trt_dir,
  pattern = "\\.shp$",
  full.names = TRUE,
  recursive = TRUE
)

shapefiles <- shapefiles[!grepl("buffer", shapefiles)]
shapefiles <- shapefiles[!grepl("Boundary", shapefiles)]
shapefiles <- shapefiles[!grepl("boundary", shapefiles)]
basename(shapefiles)
```

## Create shp_list
```{r}
shp_list <- list()
for(i in 1:length(shapefiles)){
  shp <- st_read(shapefiles[i], quiet= T) %>% st_zm()
  shp_list[[i]] <- shp
}
```

```{r}
print(paste("There are", length(shapefiles), "shapefiles and", length(shp_list), "polygon features, each saved in `shp_list`"))
```

# Prepare shapefiles & TreeMap raster for spatial overlay

### Make sure that each shapefile has TCN variable and rename if necessary
```{r}
# Define possible names for the TCN column
tcn_variants <- c("Tcn", "TreatmentC", "tcn", "treatmentc", "TNumber")

# Function to rename the TCN column in a single sf object
rename_tcn_column <- function(sf_obj) {
  current_names <- names(sf_obj)
  match_name <- current_names[current_names %in% tcn_variants]
  if (length(match_name) == 1) {
    names(sf_obj)[names(sf_obj) == match_name] <- "TCN"
  }
  return(sf_obj)
}

# Apply the function to each element in the list
shp_list <- lapply(shp_list, rename_tcn_column)
```

### Rename objective column 
```{r}
# Define possible names for the TCN column
Tobj_variants <- c("Tobj", "TreatmentO", "TObj", "TObjective", "Tobjective")

# Function to rename the TCN column in a single sf object
rename_Tobj_column <- function(sf_obj) {
  current_names <- names(sf_obj)
  match_name <- current_names[current_names %in% Tobj_variants]
  if (length(match_name) == 1) {
    names(sf_obj)[names(sf_obj) == match_name] <- "Tobj"
  }
  return(sf_obj)
}

# Apply the function to each element in the list
shp_list <- lapply(shp_list, rename_Tobj_column)
```

### Rename Activity column 
```{r}
# Define possible names for the TCN column
Tobj_variants <- c("TActivity")

# Function to rename the TCN column in a single sf object
rename_Tobj_column <- function(sf_obj) {
  current_names <- names(sf_obj)
  match_name <- current_names[current_names %in% Tobj_variants]
  if (length(match_name) == 1) {
    names(sf_obj)[names(sf_obj) == match_name] <- "Tactivity"
  }
  return(sf_obj)
}

# Apply the function to each element in the list
shp_list <- lapply(shp_list, rename_Tobj_column)
```


```{r}
for(i in 1:length(shp_list)){
  print(paste(shp_list[[i]]$TCN, "is", shp_list[[i]]$Tobj))
  }
```

# Overlap treatments and FVS variants

### Prep `fvs_varloc`
```{r}
fvs_varloc <- vect(fvs_varloc)
fvs_varloc <- makeValid(fvs_varloc)
fvs_varloc <- project(fvs_varloc, crs(tmrast))
fvs_sf <- st_as_sf(fvs_varloc)
```

### Reproject each shp to match `fvs_sf`
```{r}
for(i in 1:length(shp_list)){
  shp_list[[i]] <- st_transform(shp_list[[i]], st_crs(fvs_sf))
}
```

### Add FVS variant column to each shapefile
```{r, warning = FALSE}
# Function to intersect and assign dominant FVSVariant
assign_fvsvariant <- function(shp) {
  # Intersect with fvs_sf
  intersection <- st_intersection(shp, fvs_sf)
  
  # Calculate area of each intersected piece
  intersection$area <- st_area(intersection)
  
  # Summarize area by FVSVariant for each original polygon
  dominant_variant <- intersection %>%
    arrange(desc(area)) %>% 
    slice_max(area, n = 1) %>%
    select(FVSVariant) %>% 
    st_drop_geometry() %>% 
    unlist()
  
  # Join back to original shp
  shp$FVSVariant <- dominant_variant
  return(shp)
}
```

```{r, warning = FALSE}
shp_list <- lapply(shp_list, assign_fvsvariant)
```

### Add TCN if there is none
```{r}
for(i in 1:length(shp_list)){
  if(!"TCN" %in% names(shp_list[[i]])){
    shp_list[[i]]$TCN <- as.numeric(i)
  }else{
    shp_list[[i]]$TCN <- as.numeric(shp_list[[i]]$TCN)
  }
}
```

### Combine all shapefiles for mapping
```{r}
combined_shp <- shp_list |> bind_rows()

# Ensure valid geometries
combined_shp <- st_make_valid(combined_shp %>% st_zm)
```

```{r}
ggplot(combined_shp)+
  geom_sf(aes(fill = as.factor(TCN)), alpha = .3) 
```


# Impact Area calculations

### Create buffer polygons around each treatment and mask out the treatment area
```{r}
buffers <- list()
for (i in 1:length(shp_list)) {
  shp_sf <- shp_list[[i]]
  shp_sf$trt_area <- st_area(shp_sf)
  shp <- vect(shp_sf)
  base_name <- tools::file_path_sans_ext(basename(shapefiles[i]))

  if(shp_sf$TCN %in% noFVS){
    print(paste("Skipping TCN =", shp_sf$TCN))
    next
  }

  shp_buff <- buffer(shp, width = buffer_dist)
  shp_buff <- aggregate(
    shp_buff,
    by = c("FVSVariant", "TCN"),
    fun = function(x) x[1]
  )

  shp_buff <- erase(shp_buff, shp)
  
  shp_buff_sf <- st_as_sf(shp_buff)
  shp_buff_sf$trt_area <- as.numeric(shp_buff_sf$trt_area)
  buffers[[base_name]] <- shp_buff_sf
}
```

### Combine them and filter for fuels reduction
```{r}
buff_combined <- buffers |> bind_rows() %>% 
  filter(Tobj %in% c("Fuels Reduction", "Fuels_Reduction", "Prescribed_Fire")) %>% 
   filter(!Tactivity %in% c("Pruning", "Chipping", "Prunning"))
```


```{r}
impact_map_full <- ggplot(buff_combined)+
  geom_sf(aes(fill = as.factor(TCN)), alpha = .3)+
  ggtitle("Before removing overlaps")
```

#### Make a function for assigning the largest remaining polygon to `keep` and adding any polygons that overlap >50% with it to `ignore`
```{r}
ignore_ia <- function(){
  keep <- buff_combined %>% 
    filter(!TCN %in% keeps) %>% 
    mutate(trt_area = as.numeric(trt_area)) %>% 
    filter(trt_area == max(trt_area)) %>% 
    slice(1)
  if(nrow(keep)==0){
    return("done removing overlapping impact areas")
  }
  keeps <<- c(keeps, keep$TCN)
  print(paste("keep is", keep$TCN))
  ignore <- c()
  for(i in 1:nrow(buff_combined)){
    buff <- buff_combined[i,]
    if(buff$TCN == keep$TCN){
      next
    }
    inter <- st_intersection(buff, keep)
    ggplot(inter)+
      geom_sf(fill = "pink")+
      geom_sf(data = buff, fill = "green", alpha = 0.3)
    if (nrow(inter) > 0) {
        inter_area <- st_area(inter)
        buff_area <- st_area(buff)
        if (as.numeric(inter_area) / as.numeric(buff_area) >= 0.5) {
          ignore <- c(ignore, buff$TCN)
        }
      }
  }
  print(paste("ignoring", ignore))
  buff_combined <<- buff_combined %>% 
    filter(!TCN %in% ignore)
}
```

**Important note**: Different projects will require different numbers of repetition of the below function `ignore_ia`. Feel free to add or subtract how many times this function is repeated depending on the amount of overlap between impact areas in your project.

```{r, warning = F}
keeps <- c()
ignore_ia()
ignore_ia()
ignore_ia()
# ignore_ia()
# ignore_ia()
# ignore_ia()
# ignore_ia()
```


#### Map final impact area boundaries
```{r}
impact_map_filtered <- ggplot(buff_combined)+
  geom_sf(aes(fill = as.factor(TCN)), alpha = .3)+
  ggtitle("After removing overlaps")
```

```{r, out.width="100%", fig.height=8}
grid.arrange(impact_map_full,impact_map_filtered, nrow = 2)
```

# The TCNs that will have impact area calculations are `r buff_combined$TCN`

# Intersect the impact area polygons with TreeMap
```{r}
for(i in 1:nrow(buff_combined)){
  shp_buff_sf <- buff_combined[i,]
  shp_buff_sf <- st_transform(shp_buff_sf, crs(tmrast))
  shp_buff <- vect(shp_buff_sf )
  tm_poly_buff <- crop(tmrast, shp_buff, mask = T) %>% 
    as.polygons()

  # Intersect
  intersected_sf_buff <- terra::intersect(tm_poly_buff, shp_buff) %>% 
    st_as_sf()
    # Remove columns
  intersected_sf_buff  <- intersected_sf_buff  %>% 
    select(TM_ID, FVSVariant)
  # Calculate areas
  intersected_buff  <- intersected_sf_buff  %>% 
    mutate(area_m = as.numeric(st_area(intersected_sf_buff ))) %>% 
    mutate(area_ac = area_m/4046.8726098743) %>% 
    st_drop_geometry()
    # Write results to table and to shapefile
  file_name <- paste(output_dir, "/", "IA_areas_", shp_buff_sf$TCN, ".xlsx", sep = "")
  write_xlsx(intersected_buff, file_name)
  print(paste("Created TreeMap Polygons for impact area of", shp_buff_sf$TCN))
}
```


### Map for one impact area to check -- remove this to speed up the script
```{r}
ggplot(shp_buff_sf)+
  geom_sf()+
  geom_sf(data = intersected_sf_buff)
```


# Loop the areas calculations across all shapefiles in a path

For each shapefile in `trt_dir`, calculate the area of each value of TM_ID that intersects with that polygon and save as an excel file

```{r}
map_list <- list()
treemap_areas_list <- list()
shp_areas_list <- list()
TCN_list <- list()
for (i in 1:length(shp_list)) {
  print(i)
  shp_sf <- shp_list[[i]]
  shp <- vect(shp_sf)
  base_name <- tools::file_path_sans_ext(basename(shapefiles[i]))

  if(shp_sf$TCN %in% noFVS){
    print(paste("Skipping TCN =", shp_sf$TCN))
    next
  }

  tm_poly <- crop(tmrast, shp, mask = T) %>% 
    as.polygons %>% 
    makeValid()
  # Intersect
  intersected <- terra::intersect(tm_poly, shp)
  print(paste("Created TreeMap Polygons for trt area of", base_name))

  # convert intersected to sf 
  intersected_sf<- sf::st_as_sf(intersected)
  
  # Remove columns
  intersected_sf <- intersected_sf %>% 
    select(TM_ID, FVSVariant)
  # Calculate areas
  intersected <- intersected_sf %>% 
    mutate(area_m = as.numeric(st_area(intersected_sf))) %>% 
    mutate(area_ac = area_m/4046.8726098743) %>% 
    st_drop_geometry()
  # Write results to table and to shapefile
  file_name <- paste(output_dir, "/", base_name, "_areas.xlsx", sep = "")
  write_xlsx(intersected, file_name)
  
    # Plot using ggplot2
  map_name <- as.character(shp_sf$TCN)
  map <- ggplot() +
    geom_sf(data = intersected_sf,aes(fill = as.factor(TM_ID)), color = NA )+
    labs(fill = "TreeMapper ID (TM_ID)")+
    theme(legend.position = "none")+
    geom_sf(data = shp_sf, fill = NA)
  
  map_list[[map_name]] <- map
  
  treemap_areas_list[[base_name]] <- sum(intersected$area_ac)
  shp_areas_list[[base_name]] <- st_area(shp_sf)

  TCN_list[[base_name]] <- shp_sf$TCN
  #st_write(intersected_sf, output_dir, paste("intersected", base_name, sep = "_"), driver = "ESRI Shapefile", delete_layer = T, quiet = T)
}
```

# Find TreeMap acres for each polygon as a percentage of total shapefile area

Treemap acres = the acreage of the polygon that excludes non-forested pixels

```{r}
treemap_areas_df<- tibble(
  Name = names(treemap_areas_list),
  Value = unlist(treemap_areas_list)
) 

treemap_areas_df <- treemap_areas_df %>% 
  mutate(Value = round(Value)) %>% 
  rename("TreeMap Acres" = Value) %>% 
  rename(Shapefile = Name)
```

## Sum areas for treatments with multipart polygons
```{r}
shp_areas_list_sums <- sapply(shp_areas_list, sum)

shp_areas_df <- tibble(
  Name = names(shp_areas_list_sums),
  Value = unlist(shp_areas_list_sums)
) 
```

## Do the same for TCN
```{r}
TCN_list <- sapply(TCN_list, mean)

tcn_df <- tibble(
  Shapefile = names(TCN_list),
  TCN = unlist(TCN_list)
)
```

```{r}
shp_areas_df <- shp_areas_df %>% 
  mutate(Value = Value/4046.86) %>% 
  mutate(Value = round(Value)) %>% 
  rename("Shapefile Acres" = Value) %>% 
  rename(Shapefile = Name)

if(length(tcn_df)>0){
 shp_areas_df <- full_join(tcn_df, shp_areas_df) 
}

areas_table <- full_join(shp_areas_df, treemap_areas_df) %>% 
  mutate(Percentage = round(`TreeMap Acres`/`Shapefile Acres`*100, 1)) %>% 
  arrange(TCN)
# Print a pretty table
flextable(areas_table)
```


# Maps & Overlaps

### Plot all treatments together and highlight overlaps
```{r}
# Find overlapping areas
overlaps <- st_intersection(combined_shp) %>%
  filter(n.overlaps > 1) %>%  # Keep only actual overlaps
  mutate(Name = "Overlap")

plot_data <- bind_rows(combined_shp, overlaps)
```

```{r, out.width="100%", fig.height=12}
if(length(tcn_df)>0){
  ggplot() +
    geom_sf(data = combined_shp, aes(fill = as.factor(TCN), col = as.factor(TCN)), alpha = 0.5) + 
    geom_sf(data = overlaps, fill = "black", color = "black", alpha = 0.5) +
    theme_minimal() +
    labs(title = "All TCNs -- Overlaps are darkened",
         fill = "TCN", 
         col = "TCN")
}
```

### Plot each treatment separately, except when there are identical geometries

```{r}
map_dupes <- combined_shp %>% 
  group_by(geometry) %>% summarize(TCNs = paste(TCN, collapse = ", ")) %>% 
  st_drop_geometry()
```

If multiple TCNs are listed, it means that the maps for those TCNs look identical

```{r}
for(i in 1:nrow(map_dupes)){
  TCNs_i <- map_dupes[i, "TCNs"] %>% unlist()
  first_TCN <- strsplit(TCNs_i, ",")[[1]][1]
  print(paste("MAP FOR", TCNs_i))
  print(map_list[first_TCN])
}
```

### Identify overlapping pairs

```{r}
# Create a pairwise intersection matrix
overlap_list <- st_intersects(combined_shp, sparse = F)
rownames(overlap_list) <- combined_shp$TCN
colnames(overlap_list) <- combined_shp$TCN
diag(overlap_list) <- FALSE

# Find positions of FALSE values
true_positions <- which(overlap_list == TRUE, arr.ind = TRUE)

# Add row and column names
result <- data.frame(
  Row = rownames(overlap_list)[true_positions[, 1]],
  Column = colnames(overlap_list)[true_positions[, 2]]
)

# Create a consistent ordering for each pair
result$pair_id <- apply(result, 1, function(x) paste(sort(x), collapse = "/"))
# Keep only unique pairs
if(nrow(result)>0){
  unique_df <- result[!duplicated(result$pair_id), c("Row", "Column")]
  for(i in 1:nrow(unique_df)){
    #print(paste(unique_df[i, 1], "overlaps with", unique_df[i, 2]))
  }
}
```

```{r}
# Find overlapping areas
overlaps <- st_intersection(combined_shp) %>%
  filter(n.overlaps > 1) %>%  # Keep only actual overlaps
  mutate(Name = "Overlap")
```

### Plot each treatment group (e.g. 1.1 and 1.2) together, with overlaps

```{r}
if(length(tcn_df)>0){
  combined_shp$treatment_group <- sub("\\..*", "", combined_shp$TCN)
  overlaps$treatment_group <- sub("\\..*", "", overlaps$TCN)
}
```

```{r}
treatment_groups <- unique(combined_shp$treatment_group)
map_list2 <- list()
for(i in treatment_groups){
  combined_i <- combined_shp %>% 
    filter(treatment_group==i)
  overlaps_i <- overlaps %>% 
    filter(treatment_group == i) 
  map <- ggplot() +
    geom_sf(data = combined_i, aes(fill = as.factor(TCN), col = as.factor(TCN)), alpha = 0.5) +
    geom_sf(data = overlaps_i, fill = "black", color = "black", alpha = 0.6) +
    theme_minimal() +
    labs(title = paste0("Treatment group ", i ,", Dark is overlap"),
         fill = "TCN", 
         col = "TCN")
  map_name <- paste("Treatment_group", i, sep = "_")
  map_list2[[map_name]] <- map
}
for (i in seq_along(map_list2)) {
  print(names(map_list2)[i])
  print(map_list2[[i]])
}
```

## Plot the project in California to check FVS variant selection

```{r}
ca <- st_read(file.path(ca_dir, "CA_State_TIGER2016_5070.shp"))
```

```{r}
fvs_varloc <- st_as_sf(fvs_varloc) %>% 
  filter(FVSVariant %in% c("WS", "NC", "CA", "SO")) %>% 
  group_by(FVSVariant) |>
  summarise(geometry = st_union(geometry), .groups = "drop")
```

```{r}
centroids <- st_centroid(combined_shp %>% st_zm())
circle_buffer <- st_buffer(centroids, dist = 5000)

ggplot() +
      geom_sf(data = fvs_varloc,  aes(fill = FVSVariant), alpha = 0.2)+
    geom_sf(data = ca, fill = NA)+
  geom_sf(data = circle_buffer, col = "red", fill = "red")
```

```{r}
print(paste("FVS Variant selection is/are:"))
unique(combined_shp$FVSVariant)
```
